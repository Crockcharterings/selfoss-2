<html><head><title>.NET的Array是如何向在托管堆中申请大内存块的，或者说Array是如何实现的？</title></head><body><style type='text/css'>img{display:block;margin:0 auto;}p{font-size: 28px;}</style>
题主的原问题：<blockquote><div>.NET的Array是如何向在托管堆中申请大内存块的，或者说Array是如何实现的？<br /></div></blockquote>假定题主想问的是如何用C#或其它.NET语言，实现自定义数组类型，想知道如何从托管堆动态分配指定大小的内存；而不是想问自己如何实现一套CLI VES，其中数组的部分如何实现。<p>简短回答：如果想完全不依托CLI（Common Language Infrastructure）内建的数组类型，想要在CLI上实现自定义的<b>托管</b>数组类型是不可能的。有一条歪路但非常的不好，所以算在“不能”的范畴里。<br />注意：“托管”（managed）是重点。非托管（unmanaged）的话想怎样都可以。</p><p>=========================================</p><p>题主问Array是如何实现的，这涉及很多层面：<br /></p><ul><li>C#或其它.NET语言的语法层面：这些语言的前端编译器会对数组有特别的语法支持，对创建数组的语法最终编译生成newarr这条CIL / MSIL指令；</li><li>CLI层面：CTS（Common Type System）规范规定了数组的语义，标准库规范规定了数组类型及其基类（System.Array）需要支持的方法，CIL规范规定了一系列专门实现数组操作的字节码指令，其中分配内存的指令是newarr；</li><li>VM层面：CLI的实现，例如CLR、Mono，数组的语义贯穿于VM之中</li><li>元数据：实现数组类型的类型系统以及反射支持</li><li>GC：实现数组类型的内存分配及释放</li><li>JIT编译器：实现数组类型的操作逻辑</li></ul>正因为数组贯穿于这么多的层面，每个层面都对数组有特殊支持，想要在用户层面实现内建数组的替代品是不现实的。<p>=========================================</p><p>CLI上，涉及托管内存分配的CIL（Common Intermediate Language）/ MSIL字节码只有两条：<br /></p><ul><li>newarr &lt;etype&gt;：创建元素类型为etype的新数组对象实例<br /></li><li>newobj &lt;ctor&gt;：对引用类型，创建类的未初始化的新对象实例；对值类型，创建未初始化的新值。然后调用ctor指定的构造器进行初始化。</li></ul>没了。没有别的在CLI上标准的办法可以分配托管内存。<p>这俩指令在VM里的实现都会直接跟GC打交道，向托管堆申请内存资源。这种动作是完全被封装起来、无法从用户代码层面直接调用的。<br />例如说对于new object[10]，CLR的JIT会生成代码去调用CLR里的直接用汇编实现的<a href="http://link.zhihu.com/?target=https%3A//github.com/dotnet/coreclr/blob/959025a1ec18e6685e27c0a3ea579c78487daa25/src/vm/amd64/JitHelpers_InlineGetThread.asm%23L271" target="_blank">JIT_NewArr1OBJ_MP_InlineGetThread()<i></i></a>函数，以bump-the-pointer方式从当前线程在GC堆里分配来的alloc context分配所需的内存。</p><p>题主说：<br /></p><blockquote><div>我想自己从头实现数组类型，但是找不到向托管堆申请指定大小内存的方法！<br /></div></blockquote>因为完全封装住了，并不向用户代码层面暴露。<p>还有一条CIL / MSIL字节码是用来分配内存的，但分配的是非托管内存：<br /></p><ul><li>localloc：在“局部内存池”中分配指定大小的无类型（untyped）内存块。这主要用于支持诸如C#的unsafe功能中的stackalloc关键字之类的功能，在栈帧上动态分配内存。</li></ul>至于非托管的堆内存的分配和释放，这是通过对非托管库的调用（malloc() / free()）来实现的，在CIL / MSIL里并没有特别的指令去支持。<p>上面提到这几条字节码指令，主要是为了说明CLI所支持的托管内存分配只有两种情况，而这两种情况分别是（重要的事情再说一遍）：<br /></p><ul><li>newarr：创建新数组对象实例，例如new object[10]、new int[10]等；</li><li>newobj：对引用类型，创建类的对象实例，例如new List&lt;int&gt;()等；</li></ul>那么为啥数组对象与一般的类实例要分开对待？这是因为CLI的类型系统里，对象可以根据其类型与其大小的关系，分为3类：<br /><ol><li>不可变大小：同属某类型的对象实例全部必须是固定的大小，于是知道了对象的类型就自动知道了其大小。一般的类的实例全部都是这种情况。例如说两个System.Random对象实例，它们的大小一定是一样的。</li><li>可变大小：同属某类型的对象实例可以有不同的大小，于是知道的对象的类型还不足以知道其实例大小。所有CLI内建的数组类型都是这种情况，所以在数组对象实例里包含一个隐藏字段来记录数组长度，也就是用于实现数组的.Length属性。例如说两个int[]对象实例，数组长度并不是类型的一部分，所以两个长度不同的int[]对象实例虽然类型相同但大小却不一样。</li><li>VM直接支持的特殊类型：虽然是类的实例，但同属该类型的对象实例却可以有不同的大小。这种类型都是在VM里有特殊支持，无法在上层的用户代码里自定义的。典型例子是System.String：它有固定大小的对象头，后面粘着一个可变长度的尾巴来存储实际的字符串内容。</li></ol><br />那么像System.Collections.Generic.List这样的“可变长度容器”是如何实现的呢？请跳传送门：<br /><a href="https://www.zhihu.com/question/41169504/answer/89941026">arraylist和array在内存分配和调用、编译上有什么本质区别？ - RednaxelaFX 的回答</a><br />简单说：这些外表是“可变长度”的纯托管容器背后一定在什么地方有数组（自身就可变长度）或链式结构（串其可变个数的固定大小对象，例如链表）。当然要实现混合了非托管资源的可变长度容器也可以，但这就不在本题的“托管内存”的讨论范畴内了。<p><b>CLI对托管堆上所分配的内存有非常严格的类型安全要求，所有分配的托管内存都必须是强类型的，类型要满足上述三种情况之一；不可以分配无类型（untyped）的托管内存。通过强制要求托管堆上分配的内存都带有强类型信息，CLI的实现就可以完全掌控堆里的数据，例如说可以确保知道堆里哪些地方持有托管指针（引用）。</b><br />因此，题主想要做的，本质上是要达到上面(3)的效果，但又不想依赖(1)的支持。这在CLI上是做不到的。</p><p>=========================================</p><p>开头提到有条歪路，那是什么呢？回忆上面提到了newobj，但本回答里还没用上对不对？<br />在托管堆上分配内存不是一定要合适的类型么？那就造个“合适”的类型就好了嘛。</p><p>对于元素类型为值类型的“自定义数组”类型，可以这样做：<br /></p><ul><li>先写一个类作为这系列“自定义数组”类型的基类，实现自己需要的数组相关方法；</li><li>然后对每一个数组大小×元素类型组合，通过<a href="http://link.zhihu.com/?target=https%3A//msdn.microsoft.com/en-us/library/system.reflection.emit.typebuilder.aspx" target="_blank">System.Reflection.Emit.TypeBuilder<i></i></a>来动态创建有合适的类型及个数的字段的类，然后进一步通过反射来创建该类的实例。这样就得到了至少有自己所希望的大小的类，模拟了“指定大小动态分配托管内存”的意图。这些动态创建的类型可以放在一个字典里缓存起来，便于重复使用；</li><li>基类里实现的数组方法，不考虑效率的话可以通过反射去实现数组元素的访问（表面上实现的是数组元素访问，底下实际上通过反射访问字段来实现）；考虑效率的话可以试着用C#的unsafe功能把一堆字段当作数组来访问。</li></ul><br />这么做的话，要模拟出数组的表象还是做得到的。但背后的开销颇大，特别是可以想像会需要动态创建大量的类，给VM的元数据管理带来极大的压力，性能也未必有多好。又是何必呢。
</body></html>